package utils

import com.jamesward.zio_mavencentral.MavenCentral
import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.{ArchiveEntry, ArchiveInputStream, ArchiveStreamFactory}
import org.apache.commons.io.IOUtils
import org.eclipse.jgit.ignore.IgnoreNode

import java.io.*
import java.nio.file.{Path, Paths}
import scala.annotation.tailrec

object WebJarCreator {

  private def createDir(path: Path, jar: JarArchiveOutputStream): Unit = {
    // make sure the dir ends with a "/"
    val formattedDir = path.toString.stripSuffix("/") + "/"
    val ze = new ZipArchiveEntry(formattedDir)
    jar.putArchiveEntry(ze)
    jar.closeArchiveEntry()
  }

  private def createDirs(dir: String, jar: JarArchiveOutputStream): Unit = {
    val paths = Iterator.iterate(Paths.get(dir))(_.getParent).takeWhile(_ != null).toSeq.reverse
    paths.foreach(createDir(_, jar))
  }

  private def createFileEntry(path: String, jar: JarArchiveOutputStream, contents: String): Unit = {
    val ze = new ZipArchiveEntry(path)
    jar.putArchiveEntry(ze)
    jar.write(contents.getBytes)
    jar.closeArchiveEntry()
  }

  @tailrec
  def isExcluded(excludes: Set[String], name: String, isDirectory: Boolean): Boolean = {
    val ignoreNode = new IgnoreNode()
    val excludesInputStream = new ByteArrayInputStream(excludes.mkString("\n").getBytes)
    ignoreNode.parse(excludesInputStream)
    ignoreNode.isIgnored(name, isDirectory) match {
      case IgnoreNode.MatchResult.IGNORED => true
      case IgnoreNode.MatchResult.NOT_IGNORED => false
      case IgnoreNode.MatchResult.CHECK_PARENT | IgnoreNode.MatchResult.CHECK_PARENT_NEGATE_FIRST_MATCH =>
        val parent = name.split("/").dropRight(1).mkString("/")
        if (parent == "")
          false
        else
          isExcluded(excludes, parent, true)
    }
  }

  def removeGlobPath(glob: String, path: String): Option[String] = {
    val globParts = glob.split('/')
    val pathParts = path.split('/')

    // to match the glob, the path must have at more parts than the glob
    // this excludes the root
    if (pathParts.length <= globParts.length) {
      None
    }
    else {
      val parts = globParts.zip(pathParts)

      val removeGlob = parts.forall { case (g, s) =>
        g == "*" || g == s
      }

      Option.when(removeGlob) {
        val reassembled = pathParts.drop(globParts.length).mkString("/")
        if (path.endsWith("/")) {
          reassembled + "/"
        }
        else {
          reassembled
        }
      }
    }
  }

  def createWebJar[E <: ArchiveEntry](in: InputStream, maybeBaseDirGlob: Option[String], exclude: Set[String], pom: String, webJarName: String, licenses: Set[License], groupId: MavenCentral.GroupId, artifactId: MavenCentral.ArtifactId, version: MavenCentral.Version, pathPrefix: String): Array[Byte] = {

    val byteArrayOutputStream = new ByteArrayOutputStream()

    val bufferedByteArrayOutputStream = new BufferedOutputStream(byteArrayOutputStream)

    val jar = new ArchiveStreamFactory().createArchiveOutputStream[JarArchiveOutputStream](ArchiveStreamFactory.JAR, bufferedByteArrayOutputStream)

    val bufferedInputStream = new BufferedInputStream(in)

    val archive = new ArchiveStreamFactory().createArchiveInputStream[ArchiveInputStream[E]](bufferedInputStream)

    val webJarPrefix = s"META-INF/resources/webjars/$pathPrefix"

    // https://docs.osgi.org/specification/osgi.core/7.0.0/framework.module.html
    val manifestLicense = licenses.flatMap { license =>
      (license.maybeName, license.maybeUrl) match {
        case (Some(name), Some(url)) =>
          Some(s"$name; $url")
        case (Some(name), None) =>
          Some(name)
        case (None, Some(url)) =>
          Some(url)
        case _ =>
          None
      }
    }.mkString(",")

    // create manifest, including OSGi bundle headers
    // manifest lines (including last) must end with CRLF
    val manifest =
      s"""Manifest-Version: 1.0
         |Bundle-Description: WebJar for $webJarName
         |Bundle-License: $manifestLicense
         |Bundle-SymbolicName: $groupId.$artifactId
         |Bundle-Name: $webJarName
         |Bundle-Version: $version
         |Bundle-ManifestVersion: 2
         |Build-Jdk-Spec: 1.8
         |Created-By: webjars.org
         |""".stripMargin.replaceAll("\\r?\\n", "\r\n")

    // manifest must be the first entry in the jar
    createFileEntry("META-INF/MANIFEST.MF", jar, manifest)

    createDirs(webJarPrefix, jar)

    createFileEntry(s"META-INF/maven/$groupId/$artifactId/pom.xml", jar, pom)

    val properties = s"""
        |#Generated by WebJar Sync
        |version=$version
        |groupId=$groupId
        |artifactId=$artifactId
       """.stripMargin

    createFileEntry(s"META-INF/maven/$groupId/$artifactId/pom.properties", jar, properties)

    // todo: if the globber doesn't match on any files, likely there is a bug and we should produce an error
    // copy zip to jar
    LazyList.continually(archive.getNextEntry).takeWhile(_ != null).foreach { ze =>
      val maybeNames = maybeBaseDirGlob.fold[Array[String]](Array(ze.getName)) { baseDirGlobs =>
        baseDirGlobs.split(',').flatMap { baseDirGlob =>
          removeGlobPath(baseDirGlob, ze.getName)
        }
      }

      maybeNames.foreach { name =>
        if (!isExcluded(exclude, name, ze.isDirectory)) {
          val path = webJarPrefix + name
          val nze = new ZipArchiveEntry(path)
          jar.putArchiveEntry(nze)
          if (!ze.isDirectory) {
            IOUtils.copy(archive, jar)
          }
          jar.closeArchiveEntry()
        }
      }
    }

    archive.close()
    bufferedInputStream.close()
    in.close()

    jar.close()
    bufferedByteArrayOutputStream.close()
    byteArrayOutputStream.close()

    byteArrayOutputStream.toByteArray
  }

}
