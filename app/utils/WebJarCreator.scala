package utils

import org.apache.commons.compress.archivers.jar.JarArchiveOutputStream
import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.{ArchiveEntry, ArchiveInputStream, ArchiveStreamFactory}
import org.apache.commons.compress.utils.IOUtils
import org.eclipse.jgit.ignore.IgnoreNode

import java.io._
import java.nio.file.{Path, Paths}

object WebJarCreator {

  private def createDir(path: Path, jar: JarArchiveOutputStream): Unit = {
    // make sure the dir ends with a "/"
    val formattedDir = path.toString.stripSuffix("/") + "/"
    val ze = new ZipArchiveEntry(formattedDir)
    jar.putArchiveEntry(ze)
    jar.closeArchiveEntry()
  }

  private def createDirs(dir: String, jar: JarArchiveOutputStream): Unit = {
    val paths = Iterator.iterate(Paths.get(dir))(_.getParent).takeWhile(_ != null).toSeq.reverse
    paths.foreach(createDir(_, jar))
  }

  private def createFileEntry(path: String, jar: JarArchiveOutputStream, contents: String): Unit = {
    val ze = new ZipArchiveEntry(path)
    jar.putArchiveEntry(ze)
    jar.write(contents.getBytes)
    jar.closeArchiveEntry()
  }

  def isExcluded(excludes: Set[String], name: String, isDirectory: Boolean): Boolean = {
    val ignoreNode = new IgnoreNode()
    val excludesInputStream = new ByteArrayInputStream(excludes.mkString("\n").getBytes)
    ignoreNode.parse(excludesInputStream)
    ignoreNode.isIgnored(name, isDirectory) match {
      case IgnoreNode.MatchResult.IGNORED => true
      case IgnoreNode.MatchResult.NOT_IGNORED => false
      case IgnoreNode.MatchResult.CHECK_PARENT | IgnoreNode.MatchResult.CHECK_PARENT_NEGATE_FIRST_MATCH =>
        val parent = name.split("/").dropRight(1).mkString("/")
        if (parent == "")
          false
        else
          isExcluded(excludes, parent, true)
    }
  }

  def createWebJar[E <: ArchiveEntry](in: InputStream, contentsInSubdir: Boolean, exclude: Set[String], pom: String, groupId: String, artifactId: String, version: String, pathPrefix: String): Array[Byte] = {

    val byteArrayOutputStream = new ByteArrayOutputStream()

    val bufferedByteArrayOutputStream = new BufferedOutputStream(byteArrayOutputStream)

    val jar = new ArchiveStreamFactory().createArchiveOutputStream[JarArchiveOutputStream](ArchiveStreamFactory.JAR, bufferedByteArrayOutputStream)

    val bufferedInputStream = new BufferedInputStream(in)

    val archive = new ArchiveStreamFactory().createArchiveInputStream[ArchiveInputStream[E]](bufferedInputStream)

    val webJarPrefix = s"META-INF/resources/webjars/$pathPrefix"

    createDirs(webJarPrefix, jar)

    createFileEntry(s"META-INF/maven/$groupId/$artifactId/pom.xml", jar, pom)

    val properties = s"""
        |#Generated by WebJar Sync
        |version=$version
        |groupId=$groupId
        |artifactId=$artifactId
       """.stripMargin

    createFileEntry(s"META-INF/maven/$groupId/$artifactId/pom.properties", jar, properties)

    // copy zip to jar
    LazyList.continually(archive.getNextEntry).takeWhile(_ != null).foreach { ze =>
      val name = if (contentsInSubdir) {
        val baseName = ze.getName.split("/").tail.mkString("/")
        if (ze.isDirectory) {
          baseName + "/"
        }
        else {
          baseName
        }
      } else {
        ze.getName
      }

      if (!isExcluded(exclude, name, ze.isDirectory)) {
        val path = webJarPrefix + name
        val nze = new ZipArchiveEntry(path)
        jar.putArchiveEntry(nze)
        if (!ze.isDirectory) {
          IOUtils.copy(archive, jar)
        }
        jar.closeArchiveEntry()
      }
    }

    archive.close()
    bufferedInputStream.close()
    in.close()

    jar.close()
    bufferedByteArrayOutputStream.close()
    byteArrayOutputStream.close()

    byteArrayOutputStream.toByteArray
  }

  def emptyJar(): Array[Byte] = {
    val byteArrayOutputStream = new ByteArrayOutputStream()

    val jar = new ArchiveStreamFactory().createArchiveOutputStream[JarArchiveOutputStream](ArchiveStreamFactory.JAR, byteArrayOutputStream)
    jar.close()

    byteArrayOutputStream.toByteArray
  }

}
