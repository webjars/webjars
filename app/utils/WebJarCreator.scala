package utils

import java.io._

import org.apache.commons.compress.archivers.zip.ZipArchiveEntry
import org.apache.commons.compress.archivers.{ArchiveOutputStream, ArchiveStreamFactory}
import org.apache.commons.compress.utils.IOUtils
import org.eclipse.jgit.ignore.IgnoreNode


object WebJarCreator {

  private def createDir(dir: String, jar: ArchiveOutputStream): Unit = {
    val ze = new ZipArchiveEntry(dir)
    jar.putArchiveEntry(ze)
    jar.closeArchiveEntry()
  }

  private def createDirs(dir: String, jar: ArchiveOutputStream): Unit = {
    dir.split("/").foldLeft(Seq.empty[String]) {
      case (full, current) =>
        val newFull = full :+ current
        createDir(newFull.mkString("", "/", "/"), jar)
        newFull
    }
  }

  private def createFileEntry(path: String, jar: ArchiveOutputStream, contents: String): Unit = {
    val ze = new ZipArchiveEntry(path)
    jar.putArchiveEntry(ze)
    jar.write(contents.getBytes)
    jar.closeArchiveEntry()
  }


  def isExcluded(excludes: Set[String], name: String, isDirectory: Boolean): Boolean = {
    val ignoreNode = new IgnoreNode()
    val excludesInputStream = new ByteArrayInputStream(excludes.mkString("\n").getBytes)
    ignoreNode.parse(excludesInputStream)
    ignoreNode.isIgnored(name, isDirectory) match {
      case IgnoreNode.MatchResult.IGNORED => true
      case IgnoreNode.MatchResult.NOT_IGNORED => false
      case IgnoreNode.MatchResult.CHECK_PARENT | IgnoreNode.MatchResult.CHECK_PARENT_NEGATE_FIRST_MATCH =>
        val parent = name.split("/").dropRight(1).mkString("/")
        if (parent == "")
          false
        else
          isExcluded(excludes, parent, true)
    }
  }

  def createWebJar(in: InputStream, contentsInSubdir: Boolean, exclude: Set[String], pom: String, groupId: String, artifactId: String, version: String, pathPrefix: String): Array[Byte] = {

    val byteArrayOutputStream = new ByteArrayOutputStream()

    val bufferedByteArrayOutputStream = new BufferedOutputStream(byteArrayOutputStream)

    val jar = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.JAR, bufferedByteArrayOutputStream)

    val bufferedInputStream = new BufferedInputStream(in)

    val archive = new ArchiveStreamFactory().createArchiveInputStream(bufferedInputStream)

    createDirs(s"META-INF/maven/$groupId/$artifactId/", jar)

    createFileEntry(s"META-INF/maven/$groupId/$artifactId/pom.xml", jar, pom)

    val properties = s"""
        |#Generated by WebJar Sync
        |version=$version
        |groupId=$groupId
        |artifactId=$artifactId
       """.stripMargin

    createFileEntry(s"META-INF/maven/$groupId/$artifactId/pom.properties", jar, properties)

    val webJarPrefix = s"META-INF/resources/webjars/$pathPrefix"
    createDirs(webJarPrefix, jar)

    // copy zip to jar
    Stream.continually(archive.getNextEntry).takeWhile(_ != null).foreach { ze =>
      val name = if (contentsInSubdir) {
        val baseName = ze.getName.split("/").tail.mkString("/")
        if (ze.isDirectory) {
          baseName + "/"
        }
        else {
          baseName
        }
      } else {
        ze.getName
      }

      if (!isExcluded(exclude, name, ze.isDirectory)) {
        val path = webJarPrefix + name
        val nze = new ZipArchiveEntry(path)
        jar.putArchiveEntry(nze)
        if (!ze.isDirectory) {
          IOUtils.copy(archive, jar)
        }
        jar.closeArchiveEntry()
      }
    }

    archive.close()
    bufferedInputStream.close()
    in.close()

    jar.close()
    bufferedByteArrayOutputStream.close()
    byteArrayOutputStream.close()

    byteArrayOutputStream.toByteArray
  }

  def emptyJar(): Array[Byte] = {
    val byteArrayOutputStream = new ByteArrayOutputStream()

    val jar = new ArchiveStreamFactory().createArchiveOutputStream(ArchiveStreamFactory.JAR, byteArrayOutputStream)
    jar.close()

    byteArrayOutputStream.toByteArray
  }

}
